<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tuya IoT Dashboard</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0f1117;
  --card-bg: #222636;
  --sidebar-bg: #1a1d27;
  --accent: #3b82f6;
  --text: #e4e6eb;
  --text-secondary: #8b8fa3;
  --success: #22c55e;
  --danger: #ef4444;
  --border: #2d3148;
  --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --mono: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  --radius: 8px;
  --transition: 0.2s ease;
}

html, body { height: 100%; }

body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--text);
  line-height: 1.5;
  overflow: hidden;
}

/* ── Layout ── */
.app {
  display: grid;
  grid-template-columns: 220px 1fr;
  height: 100vh;
}

/* ── Sidebar ── */
.sidebar {
  background: var(--sidebar-bg);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  padding: 0;
  overflow-y: auto;
}

.sidebar-brand {
  padding: 24px 20px 20px;
  border-bottom: 1px solid var(--border);
}

.sidebar-brand h1 {
  font-size: 18px;
  font-weight: 700;
  color: var(--text);
  letter-spacing: -0.3px;
}

.sidebar-brand span {
  font-size: 11px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.sidebar-nav {
  list-style: none;
  padding: 12px 8px;
  flex: 1;
}

.sidebar-nav li {
  margin-bottom: 2px;
}

.sidebar-nav a {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 6px;
  color: var(--text-secondary);
  text-decoration: none;
  font-size: 14px;
  font-weight: 500;
  transition: all var(--transition);
  cursor: pointer;
  position: relative;
}

.sidebar-nav a:hover {
  background: rgba(59, 130, 246, 0.08);
  color: var(--text);
}

.sidebar-nav a.active {
  background: rgba(59, 130, 246, 0.15);
  color: var(--accent);
}

.sidebar-nav a .nav-icon {
  width: 20px;
  text-align: center;
  font-size: 16px;
  flex-shrink: 0;
}

.nav-badge {
  background: var(--danger);
  color: #fff;
  font-size: 11px;
  font-weight: 600;
  padding: 1px 6px;
  border-radius: 10px;
  margin-left: auto;
  min-width: 20px;
  text-align: center;
  display: none;
}

.nav-badge.visible { display: inline-block; }

/* ── Main ── */
.main {
  overflow-y: auto;
  padding: 32px;
}

.page-section {
  display: none;
  animation: fadeIn 0.25s ease;
}

.page-section.active { display: block; }

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(6px); }
  to { opacity: 1; transform: translateY(0); }
}

.page-header {
  margin-bottom: 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.page-header-left h2 {
  font-size: 22px;
  font-weight: 700;
  color: var(--text);
  letter-spacing: -0.3px;
}

.page-header-left p {
  color: var(--text-secondary);
  font-size: 14px;
  margin-top: 4px;
}

/* ── Edit Mode Toggle Button ── */
.edit-toggle-btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 7px 14px;
  border: 1px solid var(--border);
  border-radius: 6px;
  background: rgba(255, 255, 255, 0.04);
  color: var(--text-secondary);
  font-family: var(--font);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition);
  user-select: none;
}

.edit-toggle-btn:hover {
  background: rgba(255, 255, 255, 0.08);
  color: var(--text);
}

.edit-toggle-btn.active {
  background: rgba(59, 130, 246, 0.15);
  border-color: var(--accent);
  color: var(--accent);
}

.edit-toggle-btn .edit-icon { font-size: 14px; }

/* ── Location Groups — side-by-side layout ── */
.locations-container {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 24px;
  align-items: start;
}

.location-group {
  min-width: 0;
}

.location-group-header {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 14px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.location-group-header h3 {
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--text);
}

.location-group-header .location-count {
  font-size: 0.8rem;
  color: var(--text-secondary);
  background: var(--border);
  padding: 2px 8px;
  border-radius: 10px;
}

/* ── Cards Grid — 2 columns inside each location group ── */
.card-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 14px;
  min-height: 40px;
}

.card {
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  transition: border-color var(--transition), box-shadow var(--transition);
  cursor: default;
  position: relative;
}

.card:hover {
  border-color: rgba(59, 130, 246, 0.3);
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
}

/* ── Drag-and-drop states (only active in edit mode) ── */
.edit-mode .card {
  cursor: grab;
}

.edit-mode .card.dragging {
  opacity: 0.4;
  cursor: grabbing;
}

.edit-mode .card.drag-over {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
}

/* Subtle edit-mode border hint */
.edit-mode .card {
  border-style: dashed;
}

/* ── Device Card ── */
.device-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
}

.status-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}

.status-dot.online { background: var(--success); box-shadow: 0 0 6px rgba(34, 197, 94, 0.5); }
.status-dot.offline { background: var(--danger); box-shadow: 0 0 6px rgba(239, 68, 68, 0.3); }

.device-name {
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* ── Device Type Icon (top-right corner) ── */
.device-type-icon {
  position: absolute;
  top: 10px;
  right: 12px;
  font-size: 18px;
  opacity: 0.55;
  line-height: 1;
  pointer-events: none;
}

/* ── Expand/Collapse Toggle ── */
.card-expand-btn {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  background: none;
  border: none;
  color: var(--text-secondary);
  font-family: var(--font);
  font-size: 12px;
  cursor: pointer;
  padding: 4px 0;
  margin-top: 2px;
  transition: color var(--transition);
}

.card-expand-btn:hover { color: var(--accent); }

.card-expand-btn .expand-arrow {
  display: inline-block;
  font-size: 10px;
  transition: transform var(--transition);
}

.card-expand-btn.expanded .expand-arrow {
  transform: rotate(90deg);
}

/* ── Card Details (collapsed by default) ── */
.card-details {
  display: none;
  margin-top: 8px;
}

.card-details.visible {
  display: block;
  animation: fadeIn 0.2s ease;
}

/* ── Tags row (inside expanded details) ── */
.device-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 8px;
}

.badge {
  font-size: 11px;
  font-weight: 600;
  padding: 2px 8px;
  border-radius: 4px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.badge-category {
  background: rgba(59, 130, 246, 0.15);
  color: var(--accent);
}

.badge-id {
  background: rgba(255, 255, 255, 0.06);
  color: var(--text-secondary);
  font-family: var(--mono);
  text-transform: none;
  letter-spacing: 0;
}

.badge-success {
  background: rgba(34, 197, 94, 0.15);
  color: var(--success);
}

.badge-danger {
  background: rgba(239, 68, 68, 0.15);
  color: var(--danger);
}

.badge-warning {
  background: rgba(234, 179, 8, 0.15);
  color: #eab308;
}

.device-id {
  font-family: var(--mono);
  font-size: 11px;
  color: var(--text-secondary);
  margin-bottom: 10px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* ── Buttons ── */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 8px 16px;
  border: none;
  border-radius: 6px;
  font-family: var(--font);
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition);
  white-space: nowrap;
}

.btn-primary {
  background: var(--accent);
  color: #fff;
}

.btn-primary:hover { background: #2563eb; }
.btn-primary:active { transform: scale(0.97); }

.btn-secondary {
  background: rgba(255, 255, 255, 0.06);
  color: var(--text);
  border: 1px solid var(--border);
}

.btn-secondary:hover { background: rgba(255, 255, 255, 0.1); }

.btn-sm {
  padding: 5px 10px;
  font-size: 12px;
}

.btn-danger {
  background: rgba(239, 68, 68, 0.15);
  color: var(--danger);
}

.btn-danger:hover { background: rgba(239, 68, 68, 0.25); }

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* ── Toggle Switch ── */
.toggle-wrap {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
  border-bottom: 1px solid var(--border);
}

.toggle-wrap:last-child { border-bottom: none; }

.toggle-label {
  font-family: var(--mono);
  font-size: 12px;
  color: var(--text);
}

.toggle {
  position: relative;
  width: 44px;
  height: 24px;
  flex-shrink: 0;
}

.toggle input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  cursor: pointer;
  transition: background var(--transition);
}

.toggle-slider::before {
  content: '';
  position: absolute;
  left: 2px;
  top: 2px;
  width: 20px;
  height: 20px;
  background: #fff;
  border-radius: 50%;
  transition: transform var(--transition);
}

.toggle input:checked + .toggle-slider {
  background: var(--accent);
}

.toggle input:checked + .toggle-slider::before {
  transform: translateX(20px);
}

/* ── DP Value Row ── */
.dp-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 0;
  border-bottom: 1px solid var(--border);
  flex-wrap: wrap;
}

.dp-row:last-child { border-bottom: none; }

.dp-code {
  font-family: var(--mono);
  font-size: 12px;
  color: var(--text);
  min-width: 80px;
}

.dp-value {
  font-family: var(--mono);
  font-size: 12px;
  color: var(--text-secondary);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* ── Forms ── */
.form-row {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: flex-end;
  margin-bottom: 20px;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.form-group label {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.form-input, .form-select {
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 12px;
  color: var(--text);
  font-family: var(--font);
  font-size: 13px;
  transition: border-color var(--transition);
  outline: none;
}

.form-input:focus, .form-select:focus {
  border-color: var(--accent);
}

.form-input::placeholder { color: var(--text-secondary); }

.form-select {
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%238b8fa3' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 10px center;
  padding-right: 30px;
}

.inline-input {
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 4px 8px;
  color: var(--text);
  font-family: var(--mono);
  font-size: 12px;
  width: 100px;
  outline: none;
}

.inline-input:focus { border-color: var(--accent); }

/* ── Tables ── */
.table-wrap {
  overflow-x: auto;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: var(--card-bg);
}

table {
  width: 100%;
  border-collapse: collapse;
}

th {
  text-align: left;
  padding: 12px 16px;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  background: rgba(255, 255, 255, 0.02);
  border-bottom: 1px solid var(--border);
}

td {
  padding: 10px 16px;
  font-size: 13px;
  border-bottom: 1px solid var(--border);
  color: var(--text);
}

tr:last-child td { border-bottom: none; }

tr:hover td { background: rgba(255, 255, 255, 0.02); }

td.mono {
  font-family: var(--mono);
  font-size: 12px;
}

/* ── Stat Cards ── */
.stat-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 28px;
}

.stat-card {
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  text-align: center;
}

.stat-number {
  font-size: 36px;
  font-weight: 700;
  color: var(--text);
  line-height: 1.1;
}

.stat-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-top: 6px;
}

/* ── Events Feed ── */
.event-status {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
  font-size: 13px;
}

.event-status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
}

.event-status-dot.connecting { background: #eab308; animation: pulse 1.5s infinite; }
.event-status-dot.connected { background: var(--success); }
.event-status-dot.disconnected { background: var(--danger); }

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

.event-feed {
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: calc(100vh - 240px);
  overflow-y: auto;
}

.event-item {
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px 16px;
  animation: fadeIn 0.2s ease;
}

.event-item-header {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 6px;
}

.event-time {
  font-size: 12px;
  color: var(--text-secondary);
  font-family: var(--mono);
}

.event-type {
  font-size: 11px;
  font-weight: 600;
  padding: 1px 6px;
  border-radius: 4px;
  text-transform: uppercase;
}

.event-device {
  font-family: var(--mono);
  font-size: 12px;
  color: var(--text-secondary);
  margin-left: auto;
}

.event-data {
  font-family: var(--mono);
  font-size: 12px;
  color: var(--text-secondary);
  background: rgba(0, 0, 0, 0.2);
  padding: 8px 10px;
  border-radius: 4px;
  white-space: pre-wrap;
  word-break: break-all;
  max-height: 120px;
  overflow-y: auto;
}

/* ── Scenes ── */
.scene-card {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.scene-name {
  font-size: 15px;
  font-weight: 600;
}

.scene-id {
  font-family: var(--mono);
  font-size: 12px;
  color: var(--text-secondary);
  margin-top: 2px;
}

/* ── Quick Controls (minimized card) ── */
.card-quick-controls {
  margin-top: 6px;
  min-height: 28px;
}

.quick-battery {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-size: 11px;
  color: var(--text-secondary);
  margin-bottom: 4px;
}

.quick-battery .batt-icon { font-size: 13px; }
.quick-battery.low { color: var(--danger); }
.quick-battery.mid { color: #eab308; }
.quick-battery.high { color: var(--success); }

.quick-row {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

/* ── Lock Unlock Button ── */
.unlock-btn {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 5px 12px;
  border: 1px solid var(--border);
  border-radius: 6px;
  background: rgba(255, 255, 255, 0.04);
  color: var(--text);
  font-family: var(--font);
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition);
}

.unlock-btn:hover { background: rgba(59, 130, 246, 0.12); border-color: var(--accent); }
.unlock-btn:disabled { opacity: 0.5; cursor: not-allowed; }

.unlock-btn.unlocked {
  background: rgba(34, 197, 94, 0.15);
  border-color: var(--success);
  color: var(--success);
}

.unlock-btn.unlocking {
  background: rgba(234, 179, 8, 0.15);
  border-color: #eab308;
  color: #eab308;
}

.unlock-countdown {
  font-family: var(--mono);
  font-size: 11px;
  margin-left: 2px;
}

/* ── Brightness Slider ── */
.brightness-wrap {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  min-width: 0;
}

.brightness-slider {
  -webkit-appearance: none;
  appearance: none;
  flex: 1;
  height: 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.1);
  outline: none;
  cursor: pointer;
}

.brightness-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: 2px solid var(--card-bg);
  box-shadow: 0 0 4px rgba(59, 130, 246, 0.4);
}

.brightness-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: 2px solid var(--card-bg);
}

.brightness-pct {
  font-family: var(--mono);
  font-size: 11px;
  color: var(--text-secondary);
  min-width: 32px;
  text-align: right;
}

/* ── Momentary / Toggle Buttons ── */
.quick-toggle-btn {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 10px;
  border: 1px solid var(--border);
  border-radius: 5px;
  background: rgba(255, 255, 255, 0.04);
  color: var(--text-secondary);
  font-family: var(--font);
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition);
}

.quick-toggle-btn:hover {
  background: rgba(59, 130, 246, 0.12);
  color: var(--text);
  border-color: var(--accent);
}

.quick-toggle-btn.on {
  background: rgba(59, 130, 246, 0.2);
  border-color: var(--accent);
  color: var(--accent);
}

/* ── Device DPs Area ── */
.device-dps {
  border-top: 1px solid var(--border);
  padding-top: 8px;
}

/* ── Toast ── */
.toast-container {
  position: fixed;
  bottom: 24px;
  right: 24px;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.toast {
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 10px 16px;
  font-size: 13px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  animation: slideIn 0.25s ease;
  max-width: 360px;
}

.toast.success { border-left: 3px solid var(--success); }
.toast.error { border-left: 3px solid var(--danger); }

@keyframes slideIn {
  from { opacity: 0; transform: translateX(20px); }
  to { opacity: 1; transform: translateX(0); }
}

/* ── Misc ── */
.empty-state {
  text-align: center;
  padding: 48px 20px;
  color: var(--text-secondary);
  font-size: 14px;
}

.loading {
  text-align: center;
  padding: 20px;
  color: var(--text-secondary);
  font-size: 13px;
}

.section-title {
  font-size: 16px;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 12px;
}

.result-count {
  font-size: 13px;
  color: var(--text-secondary);
  margin-bottom: 12px;
}

.home-input-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 20px;
}
</style>
</head>
<body>
<div class="app">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="sidebar-brand">
      <h1>Tuya IoT</h1>
      <span>Dashboard</span>
    </div>
    <ul class="sidebar-nav">
      <li><a data-page="devices" onclick="navigate('devices')">
        <span class="nav-icon">&#9671;</span> Devices
      </a></li>
      <li><a data-page="scenes" onclick="navigate('scenes')">
        <span class="nav-icon">&#9881;</span> Scenes
      </a></li>
      <li><a data-page="logs" onclick="navigate('logs')">
        <span class="nav-icon">&#9776;</span> Logs
      </a></li>
      <li><a data-page="events" onclick="navigate('events')">
        <span class="nav-icon">&#9889;</span> Events
        <span id="event-badge" class="nav-badge">0</span>
      </a></li>
      <li><a data-page="status" onclick="navigate('status')">
        <span class="nav-icon">&#9635;</span> Status
      </a></li>
    </ul>
  </aside>

  <!-- Main Content -->
  <main class="main">

    <!-- DEVICES PAGE -->
    <section id="page-devices" class="page-section">
      <div class="page-header">
        <div class="page-header-left">
          <h2>Devices</h2>
          <p>Manage and control your connected devices</p>
        </div>
        <button id="edit-mode-btn" class="edit-toggle-btn" onclick="pages.devices.toggleEditMode()">
          <span class="edit-icon">&#9998;</span> Reorder
        </button>
      </div>
      <div id="devices-grid"></div>
    </section>

    <!-- SCENES PAGE -->
    <section id="page-scenes" class="page-section">
      <div class="page-header">
        <div class="page-header-left">
          <h2>Scenes</h2>
          <p>View and trigger automation scenes</p>
        </div>
      </div>
      <div id="scenes-home-input" class="home-input-row" style="display:none;">
        <label style="font-size:13px;color:var(--text-secondary);">Space ID:</label>
        <input id="home-id-input" class="form-input" placeholder="Enter space ID"
          style="width:260px;">
        <button class="btn btn-primary btn-sm" onclick="pages.scenes.setHomeId()">Set</button>
      </div>
      <div id="scenes-grid" class="card-grid"></div>
    </section>

    <!-- LOGS PAGE -->
    <section id="page-logs" class="page-section">
      <div class="page-header">
        <div class="page-header-left">
          <h2>Logs</h2>
          <p>Search device event logs</p>
        </div>
      </div>
      <div class="form-row">
        <div class="form-group">
          <label>Device</label>
          <select id="log-device" class="form-select" style="min-width:200px;">
            <option value="">All Devices</option>
          </select>
        </div>
        <div class="form-group">
          <label>Start</label>
          <input id="log-start" type="datetime-local" class="form-input">
        </div>
        <div class="form-group">
          <label>End</label>
          <input id="log-end" type="datetime-local" class="form-input">
        </div>
        <div class="form-group">
          <label>Code</label>
          <input id="log-code" class="form-input" placeholder="e.g. switch_1" style="width:140px;">
        </div>
        <div class="form-group">
          <label>&nbsp;</label>
          <button class="btn btn-primary" onclick="pages.logs.search()">Search</button>
        </div>
      </div>
      <div id="logs-count" class="result-count"></div>
      <div id="logs-table-wrap"></div>
    </section>

    <!-- EVENTS PAGE -->
    <section id="page-events" class="page-section">
      <div class="page-header">
        <div class="page-header-left">
          <h2>Events</h2>
          <p>Real-time event stream from devices</p>
        </div>
      </div>
      <div class="event-status">
        <span id="event-status-dot" class="event-status-dot disconnected"></span>
        <span id="event-status-text">Disconnected</span>
      </div>
      <div id="event-feed" class="event-feed"></div>
    </section>

    <!-- STATUS PAGE -->
    <section id="page-status" class="page-section">
      <div class="page-header">
        <div class="page-header-left">
          <h2>Status</h2>
          <p>System overview and collection statistics</p>
        </div>
      </div>
      <div id="status-stats" class="stat-grid"></div>
      <h3 class="section-title">Device Bookmarks</h3>
      <div id="status-bookmarks" class="table-wrap" style="margin-bottom:28px;"></div>
      <h3 class="section-title">Recent Collection Runs</h3>
      <div id="status-runs" class="table-wrap"></div>
    </section>

  </main>
</div>

<div id="toast-container" class="toast-container"></div>

<script>
/* ─────────────────────────── State ─────────────────────────── */
const state = {
  currentPage: null,
  devices: [],
  spaces: {},       // { spaceId: "Space Name", ... }
  deviceStatus: {},  // { deviceId: { status: [...], functions: [...] } }
  scenes: [],
  events: [],
  eventSource: null,
  homeId: null,
  unseenEvents: 0,
  editMode: false,
};

/* ─────────────────────────── Device type icons ─────────────────────────── */
const CATEGORY_ICONS = {
  // Lighting
  dj:  '\u{1F4A1}',  // light bulb — dimmer
  dd:  '\u{1F4A1}',  // light strip
  fwd: '\u{1F4A1}',  // ambient light
  xdd: '\u{1F4A1}',  // ceiling light
  dc:  '\u{1F4A1}',  // string light
  // Switches
  kg:  '\u{1F4A1}',  // wall switch (light switch)
  pc:  '\u{1F50C}',  // power strip
  cz:  '\u{1F50C}',  // smart plug
  // Locks
  jtmspro: '\u{1F512}',  // smart lock pro
  ms:  '\u{1F512}',  // lock
  jtms: '\u{1F512}',  // lock (alt)
  // Gateways
  wg2: '\u{1F4F6}',  // bluetooth gateway
  wg:  '\u{1F4F6}',  // gateway
  // Remote / controllers
  tdq: '\u{1F4E1}',  // remote control
  ykq: '\u{1F4E1}',  // remote
  // Sensors
  mcs: '\u{1F6AA}',  // door sensor
  pir: '\u{1F441}',  // motion sensor
  wsdcg: '\u{1F321}', // temp/humidity
  // Climate
  kt:  '\u{2744}',  // AC
  // Camera
  sp:  '\u{1F4F7}',  // camera
  // Curtains
  cl:  '\u{1FA9F}',  // curtain
  // Robot vacuum
  sd:  '\u{1F9F9}',  // robot vacuum
};

function categoryIcon(category) {
  if (!category) return '';
  return CATEGORY_ICONS[category.toLowerCase()] || '\u{1F4E6}'; // default box
}

/* ─────────────────────────── Helpers ─────────────────────────── */
function esc(str) {
  if (str == null) return '';
  const d = document.createElement('div');
  d.textContent = String(str);
  return d.innerHTML;
}

function deviceName(d) {
  return d.customName || d.custom_name || d.name || d.id;
}

function formatTime(ms) {
  if (!ms) return '---';
  const d = new Date(typeof ms === 'number' ? ms : ms);
  return d.toLocaleString();
}

function formatISOLocal(date) {
  const pad = (n) => String(n).padStart(2, '0');
  return date.getFullYear() + '-' + pad(date.getMonth() + 1) + '-' + pad(date.getDate()) +
    'T' + pad(date.getHours()) + ':' + pad(date.getMinutes());
}

function toast(message, type) {
  const c = document.getElementById('toast-container');
  const el = document.createElement('div');
  el.className = 'toast ' + (type || 'success');
  el.textContent = message;
  c.appendChild(el);
  setTimeout(() => { el.style.opacity = '0'; setTimeout(() => el.remove(), 300); }, 3000);
}

function eventTypeColor(type) {
  const colors = {
    online: 'var(--success)',
    offline: 'var(--danger)',
    status_report: 'var(--accent)',
    data_report: '#a78bfa',
  };
  return colors[type] || '#eab308';
}

/* ─────────────────────── Card Order Persistence ─────────────────────── */
const CARD_ORDER_KEY = 'tuya_card_order';

function loadCardOrder() {
  try {
    const raw = localStorage.getItem(CARD_ORDER_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch { return {}; }
}

function saveCardOrder(spaceId, deviceIds) {
  const orders = loadCardOrder();
  orders[spaceId] = deviceIds;
  localStorage.setItem(CARD_ORDER_KEY, JSON.stringify(orders));
}

function applyCardOrder(spaceId, devices) {
  const orders = loadCardOrder();
  const order = orders[spaceId];
  if (!order || !order.length) return devices;

  const map = {};
  devices.forEach((d) => { map[d.id] = d; });

  const ordered = [];
  order.forEach((id) => {
    if (map[id]) { ordered.push(map[id]); delete map[id]; }
  });
  // Append any new devices not in saved order.
  Object.values(map).forEach((d) => ordered.push(d));
  return ordered;
}

/* ─────────────────────── Card Expand/Collapse ─────────────────────── */
const EXPANDED_KEY = 'tuya_expanded_cards';

function loadExpanded() {
  try {
    const raw = localStorage.getItem(EXPANDED_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch { return {}; }
}

function saveExpanded(deviceId, isExpanded) {
  const map = loadExpanded();
  if (isExpanded) {
    map[deviceId] = true;
  } else {
    delete map[deviceId];
  }
  localStorage.setItem(EXPANDED_KEY, JSON.stringify(map));
}

function toggleCardExpand(deviceId) {
  const details = document.getElementById('details-' + deviceId);
  const btn = document.getElementById('expand-btn-' + deviceId);
  if (!details || !btn) return;

  const isVisible = details.classList.contains('visible');
  if (isVisible) {
    details.classList.remove('visible');
    btn.classList.remove('expanded');
    saveExpanded(deviceId, false);
  } else {
    details.classList.add('visible');
    btn.classList.add('expanded');
    saveExpanded(deviceId, true);
    // Load status if not already loaded.
    const dps = document.getElementById('dps-' + deviceId);
    if (dps && dps.dataset.loaded !== 'true') {
      pages.devices.loadStatus(deviceId);
    }
  }
}

/* ─────────────────────────── API ─────────────────────────── */
const api = {
  async get(path) {
    const res = await fetch(path);
    if (!res.ok) throw new Error(`GET ${path}: ${res.status}`);
    return res.json();
  },
  async post(path, body) {
    const res = await fetch(path, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error(`POST ${path}: ${res.status}`);
    return res.json();
  },
};

/* ─────────────────────────── Pages ─────────────────────────── */
const pages = {

  /* ── Devices ── */
  devices: {
    async load() {
      try {
        const data = await api.get('/api/devices');
        state.devices = data.list || data || [];
        await this.resolveSpaces();
        this.render();
      } catch (e) {
        toast('Failed to load devices: ' + e.message, 'error');
      }
    },

    async resolveSpaces() {
      const ids = new Set();
      state.devices.forEach((d) => {
        const sid = d.bindSpaceId || d.bind_space_id;
        if (sid && !state.spaces[sid]) ids.add(String(sid));
      });
      await Promise.all([...ids].map(async (sid) => {
        try {
          const info = await api.get('/api/spaces/' + encodeURIComponent(sid));
          if (info && info.name) {
            state.spaces[sid] = info.name;
          } else {
            state.spaces[sid] = sid;
          }
        } catch {
          state.spaces[sid] = sid;
        }
      }));
    },

    toggleEditMode() {
      state.editMode = !state.editMode;
      const btn = document.getElementById('edit-mode-btn');
      const container = document.getElementById('devices-grid');
      if (state.editMode) {
        btn.classList.add('active');
        container.classList.add('edit-mode');
        // Enable draggable on all cards.
        container.querySelectorAll('.card[data-device-id]').forEach((c) => {
          c.setAttribute('draggable', 'true');
        });
      } else {
        btn.classList.remove('active');
        container.classList.remove('edit-mode');
        // Disable draggable on all cards.
        container.querySelectorAll('.card[data-device-id]').forEach((c) => {
          c.removeAttribute('draggable');
        });
      }
    },

    render() {
      const container = document.getElementById('devices-grid');
      if (!state.devices.length) {
        container.innerHTML = '<div class="empty-state">No devices found</div>';
        return;
      }

      const expanded = loadExpanded();

      // Group devices by location (bindSpaceId).
      const groupMap = {};
      const groupOrder = [];
      state.devices.forEach((d) => {
        const sid = String(d.bindSpaceId || d.bind_space_id || '_ungrouped');
        if (!groupMap[sid]) { groupMap[sid] = []; groupOrder.push(sid); }
        groupMap[sid].push(d);
      });

      let html = '<div class="locations-container">';
      for (const sid of groupOrder) {
        const devices = applyCardOrder(sid, groupMap[sid]);
        const spaceName = state.spaces[sid] || (sid === '_ungrouped' ? 'Other' : sid);
        html += `
          <div class="location-group" data-space-id="${esc(sid)}">
            <div class="location-group-header">
              <h3>${esc(spaceName)}</h3>
              <span class="location-count">${devices.length} device${
                devices.length !== 1 ? 's' : ''
              }</span>
            </div>
            <div class="card-grid" data-space-id="${esc(sid)}">`;
        devices.forEach((d) => {
          const name = esc(deviceName(d));
          const online = d.isOnline === true || d.online === true;
          const icon = categoryIcon(d.category);
          const isExpanded = !!expanded[d.id];
          const expandedClass = isExpanded ? ' expanded' : '';
          const detailsClass = isExpanded ? ' visible' : '';

          html += `
              <div class="card" data-device-id="${esc(d.id)}"
                id="device-card-${esc(d.id)}">
                <span class="device-type-icon" title="${esc(
                  d.category ? d.category.toUpperCase() : ''
                )}">${icon}</span>
                <div class="device-header">
                  <span class="status-dot ${online ? 'online' : 'offline'}"></span>
                  <span class="device-name" title="${name}">${name}</span>
                </div>
                <div class="card-quick-controls"
                  id="quick-${esc(d.id)}"
                  data-category="${esc(d.category || '')}"
                  data-device-name="${esc(deviceName(d))}"></div>
                <button class="card-expand-btn${expandedClass}"
                  id="expand-btn-${esc(d.id)}"
                  onclick="toggleCardExpand('${esc(d.id)}')">
                  <span class="expand-arrow">&#9654;</span>
                  Details
                </button>
                <div class="card-details${detailsClass}" id="details-${esc(d.id)}">
                  <div class="device-tags">
                    ${d.category ? `<span class="badge badge-category">${
                      esc(d.category.toUpperCase())
                    }</span>` : ''}
                    <span class="badge badge-id">${esc(d.id)}</span>
                  </div>
                  <div class="device-dps" id="dps-${esc(d.id)}" data-loaded="false">
                    <div class="loading">Loading status...</div>
                  </div>
                </div>
              </div>`;
        });
        html += `
            </div>
          </div>`;
      }
      html += '</div>';

      // Preserve edit mode class if active.
      const wasEditMode = container.classList.contains('edit-mode');
      container.innerHTML = html;
      if (wasEditMode || state.editMode) {
        container.classList.add('edit-mode');
        container.querySelectorAll('.card[data-device-id]').forEach((c) => {
          c.setAttribute('draggable', 'true');
        });
      }

      // Wire up drag-and-drop on all card grids.
      container.querySelectorAll('.card-grid[data-space-id]').forEach((grid) => {
        this.initDragDrop(grid);
      });

      // Auto-load status for expanded cards only.
      this.autoLoadStatus(expanded);
    },

    /* ── Drag-and-Drop ── */
    initDragDrop(grid) {
      let draggedCard = null;

      grid.addEventListener('dragstart', (e) => {
        if (!state.editMode) { e.preventDefault(); return; }
        const card = e.target.closest('.card[data-device-id]');
        if (!card) return;
        draggedCard = card;
        card.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', card.dataset.deviceId);
      });

      grid.addEventListener('dragend', (e) => {
        const card = e.target.closest('.card[data-device-id]');
        if (card) card.classList.remove('dragging');
        grid.querySelectorAll('.drag-over').forEach((el) => el.classList.remove('drag-over'));
        draggedCard = null;
      });

      grid.addEventListener('dragover', (e) => {
        if (!state.editMode) return;
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        const target = e.target.closest('.card[data-device-id]');
        grid.querySelectorAll('.drag-over').forEach((el) => el.classList.remove('drag-over'));
        if (target && target !== draggedCard) {
          target.classList.add('drag-over');
        }
      });

      grid.addEventListener('dragleave', (e) => {
        const target = e.target.closest('.card[data-device-id]');
        if (target) target.classList.remove('drag-over');
      });

      grid.addEventListener('drop', (e) => {
        if (!state.editMode) return;
        e.preventDefault();
        grid.querySelectorAll('.drag-over').forEach((el) => el.classList.remove('drag-over'));
        if (!draggedCard) return;

        const target = e.target.closest('.card[data-device-id]');
        if (!target || target === draggedCard) return;

        // Determine position: insert before or after target.
        const rect = target.getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        if (e.clientY < midY) {
          grid.insertBefore(draggedCard, target);
        } else {
          grid.insertBefore(draggedCard, target.nextSibling);
        }

        // Persist the new order.
        const spaceId = grid.dataset.spaceId;
        const newOrder = [...grid.querySelectorAll('.card[data-device-id]')]
          .map((c) => c.dataset.deviceId);
        saveCardOrder(spaceId, newOrder);
      });
    },

    autoLoadStatus(expanded) {
      // Load status for ALL devices to populate quick controls.
      state.devices.forEach((d) => {
        this.fetchDeviceData(d.id, !!(expanded || loadExpanded())[d.id]);
      });
    },

    async fetchDeviceData(deviceId, alsoRenderDetails) {
      try {
        const [statusData, funcData] = await Promise.all([
          api.get(`/api/devices/${deviceId}/status`),
          api.get(`/api/devices/${deviceId}/functions`).catch(() => ({
            functions: [],
          })),
        ]);

        const statusList = Array.isArray(statusData)
          ? statusData
          : (statusData.result || statusData.status || []);
        const funcList = funcData.functions || funcData.result?.functions || [];
        const funcMap = {};
        funcList.forEach((f) => { funcMap[f.code] = f; });

        state.deviceStatus[deviceId] = { status: statusList, funcMap };

        // Always render quick controls.
        this.renderQuickControls(deviceId);

        // Render expanded details if needed.
        if (alsoRenderDetails) {
          this.renderDetails(deviceId);
        }
      } catch (e) {
        const quickEl = document.getElementById('quick-' + deviceId);
        if (quickEl) quickEl.innerHTML = '';
      }
    },

    /* ── Quick Controls ── */
    renderQuickControls(deviceId) {
      const quickEl = document.getElementById('quick-' + deviceId);
      if (!quickEl) return;

      const cached = state.deviceStatus[deviceId];
      if (!cached) return;

      const { status, funcMap } = cached;
      const statusMap = {};
      status.forEach((dp) => { statusMap[dp.code] = dp.value; });

      const category = (quickEl.dataset.category || '').toLowerCase();
      const dName = quickEl.dataset.deviceName || '';
      let html = '';

      // Battery (residual_electricity) — shown for any device that has it.
      if (statusMap.residual_electricity != null) {
        const batt = Number(statusMap.residual_electricity);
        const cls = batt <= 20 ? 'low' : batt <= 50 ? 'mid' : 'high';
        const icon = batt <= 20 ? '\u{1FAAB}' : '\u{1F50B}';
        html += `<div class="quick-battery ${cls}">
          <span class="batt-icon">${icon}</span> ${batt}%
        </div>`;
      }

      html += '<div class="quick-row">';

      // Determine which quick control to show based on device type.
      const isLock = category === 'jtmspro' || category === 'jtms' || category === 'ms';
      const isCarRemote = /car.*remote|car.*hhr/i.test(dName);
      const isDimmer = statusMap.bright_value != null && funcMap.bright_value;

      if (isLock) {
        // Lock: show unlock button via ble_unlock_check with 20s visual timer.
        const locked = statusMap.lock_motor_state !== true;
        html += `<button class="unlock-btn" id="unlock-btn-${esc(deviceId)}"
          onclick="pages.devices.tempUnlock('${esc(deviceId)}')"
          title="Temporarily unlock for 20 seconds">
          ${locked ? '\u{1F512}' : '\u{1F513}'} Unlock
        </button>`;
      } else if (isCarRemote) {
        // Car Remote HHR: show toggle_1, toggle_2, toggle_3 as momentary buttons.
        [1, 2, 3].forEach((n) => {
          const code = `switch_${n}`;
          const isOn = statusMap[code] === true;
          html += `<button class="quick-toggle-btn${isOn ? ' on' : ''}"
            onclick="pages.devices.momentaryToggle('${esc(deviceId)}', '${code}', this)"
            title="${code}">
            ${n}
          </button>`;
        });
      } else if (isDimmer) {
        // Dimmer light: show brightness slider (and switch_led toggle).
        const bright = Number(statusMap.bright_value) || 25;
        const valInfo = funcMap.bright_value.values ?
          JSON.parse(funcMap.bright_value.values) : {};
        const min = valInfo.min || 25;
        const max = valInfo.max || 255;
        const pct = Math.round(((bright - min) / (max - min)) * 100);
        const switchOn = statusMap.switch_led === true;
        html += `<label class="toggle" style="flex-shrink:0;">
            <input type="checkbox" ${switchOn ? 'checked' : ''}
              onchange="pages.devices.sendCommand('${esc(deviceId)}',
                'switch_led', this.checked)">
            <span class="toggle-slider"></span>
          </label>
          <div class="brightness-wrap">
            <input type="range" class="brightness-slider"
              id="bright-${esc(deviceId)}"
              min="${min}" max="${max}" value="${bright}"
              oninput="pages.devices.updateBrightLabel('${esc(deviceId)}',
                this.value, ${min}, ${max})"
              onchange="pages.devices.sendCommand('${esc(deviceId)}',
                'bright_value', Number(this.value))">
            <span class="brightness-pct"
              id="bright-pct-${esc(deviceId)}">${pct}%</span>
          </div>`;
      } else if (statusMap.switch_1 != null && funcMap.switch_1) {
        // Generic switch_1 toggle (plugs, lights, Outer Door, etc.).
        const isOn = statusMap.switch_1 === true;
        html += `<label class="toggle">
            <input type="checkbox" ${isOn ? 'checked' : ''}
              onchange="pages.devices.sendCommand('${esc(deviceId)}',
                'switch_1', this.checked)">
            <span class="toggle-slider"></span>
          </label>`;
      }

      html += '</div>';
      quickEl.innerHTML = html;
    },

    updateBrightLabel(deviceId, value, min, max) {
      const pctEl = document.getElementById('bright-pct-' + deviceId);
      if (pctEl) {
        const pct = Math.round(((Number(value) - min) / (max - min)) * 100);
        pctEl.textContent = pct + '%';
      }
    },

    /* ── Temporary Unlock (20-second visual timer) ── */
    async tempUnlock(deviceId) {
      const btn = document.getElementById('unlock-btn-' + deviceId);
      if (!btn || btn.disabled) return;
      btn.disabled = true;

      try {
        // Send BLE unlock check command with its current status value.
        const cached = state.deviceStatus[deviceId];
        const statusMap = {};
        if (cached) cached.status.forEach((dp) => { statusMap[dp.code] = dp.value; });
        const bleVal = statusMap.ble_unlock_check || '';
        await api.post(`/api/devices/${deviceId}/commands`, {
          commands: [{ code: 'ble_unlock_check', value: bleVal }],
        });

        btn.classList.add('unlocked');
        btn.innerHTML = '\u{1F513} Unlocked <span class="unlock-countdown">20s</span>';

        let remaining = 20;
        const interval = setInterval(() => {
          remaining--;
          const span = btn.querySelector('.unlock-countdown');
          if (span) span.textContent = remaining + 's';
          if (remaining <= 0) {
            clearInterval(interval);
            // Visual reset only — lock re-engages on its own.
            btn.classList.remove('unlocked');
            btn.innerHTML = '\u{1F512} Unlock';
            btn.disabled = false;
          }
        }, 1000);
      } catch (e) {
        btn.disabled = false;
        toast('Unlock failed: ' + e.message, 'error');
      }
    },

    /* ── Momentary toggle for Car Remote buttons ── */
    async momentaryToggle(deviceId, code, btn) {
      if (btn.disabled) return;
      btn.disabled = true;
      try {
        await api.post(`/api/devices/${deviceId}/commands`, {
          commands: [{ code, value: true }],
        });
        btn.classList.add('on');
        toast(`Sent ${code} = true`, 'success');
        // The remote's switch_type is "button" so it auto-resets.
        setTimeout(() => {
          btn.classList.remove('on');
          btn.disabled = false;
        }, 1500);
      } catch (e) {
        btn.disabled = false;
        toast('Command failed: ' + e.message, 'error');
      }
    },

    /* ── Expanded Details ── */
    renderDetails(deviceId) {
      const dpsEl = document.getElementById('dps-' + deviceId);
      if (!dpsEl) return;

      const cached = state.deviceStatus[deviceId];
      if (!cached) return;

      const { status, funcMap } = cached;
      const funcCodes = new Set(Object.keys(funcMap));

      let html = '';
      status.forEach((dp) => {
        const fn = funcMap[dp.code];
        const isBool = (fn && fn.type === 'Boolean') ||
          (typeof dp.value === 'boolean') ||
          (fn && fn.values && /"type":\s*"bool"/.test(fn.values));

        if (isBool && funcCodes.has(dp.code)) {
          const checked = dp.value === true || dp.value === 'true' ? 'checked' : '';
          html += `
            <div class="toggle-wrap">
              <span class="toggle-label">${esc(dp.code)}</span>
              <label class="toggle">
                <input type="checkbox" ${checked}
                  onchange="pages.devices.sendCommand('${esc(deviceId)}',
                    '${esc(dp.code)}', this.checked)">
                <span class="toggle-slider"></span>
              </label>
            </div>`;
        } else if (funcCodes.has(dp.code)) {
          html += `
            <div class="dp-row">
              <span class="dp-code">${esc(dp.code)}</span>
              <span class="dp-value">${esc(JSON.stringify(dp.value))}</span>
              <input class="inline-input"
                id="input-${esc(deviceId)}-${esc(dp.code)}"
                value="${esc(
                  typeof dp.value === 'object' ? JSON.stringify(dp.value) : dp.value
                )}"
                placeholder="value">
              <button class="btn btn-primary btn-sm"
                onclick="pages.devices.sendFromInput('${esc(deviceId)}',
                  '${esc(dp.code)}')">Send</button>
            </div>`;
        } else {
          html += `
            <div class="dp-row">
              <span class="dp-code">${esc(dp.code)}</span>
              <span class="dp-value">${esc(JSON.stringify(dp.value))}</span>
            </div>`;
        }
      });

      dpsEl.innerHTML = html ||
        '<div class="empty-state" style="padding:8px;">No data points</div>';
      dpsEl.dataset.loaded = 'true';
    },

    async loadStatus(deviceId) {
      // Delegate to fetchDeviceData which handles both quick + detail rendering.
      await this.fetchDeviceData(deviceId, true);
    },

    async sendCommand(deviceId, code, value) {
      try {
        let parsed = value;
        if (typeof value === 'string') {
          try { parsed = JSON.parse(value); } catch { parsed = value; }
        }
        await api.post(`/api/devices/${deviceId}/commands`, {
          commands: [{ code, value: parsed }],
        });
        toast(`Sent ${code} = ${JSON.stringify(parsed)}`, 'success');
      } catch (e) {
        toast('Command failed: ' + e.message, 'error');
      }
    },

    sendFromInput(deviceId, code) {
      const input = document.getElementById(`input-${deviceId}-${code}`);
      if (!input) return;
      this.sendCommand(deviceId, code, input.value);
    },
  },

  /* ── Scenes ── */
  scenes: {
    async load() {
      // Gather unique space IDs from loaded devices.
      const spaceIds = new Set();
      state.devices.forEach((d) => {
        const sid = d.bindSpaceId || d.bind_space_id;
        if (sid) spaceIds.add(String(sid));
      });

      if (!spaceIds.size) {
        document.getElementById('scenes-home-input').style.display = 'flex';
        document.getElementById('scenes-grid').innerHTML =
          '<div class="empty-state">No spaces found. Enter a Space ID manually.</div>';
        return;
      }
      document.getElementById('scenes-home-input').style.display = 'none';

      try {
        // Fetch scenes from all spaces in parallel.
        const results = await Promise.all([...spaceIds].map(async (sid) => {
          try {
            const data = await api.get(
              `/api/spaces/${encodeURIComponent(sid)}/scenes`
            );
            const list = data.list || (Array.isArray(data) ? data : []);
            return list;
          } catch {
            return [];
          }
        }));
        state.scenes = results.flat();
        this.render();
      } catch (e) {
        toast('Failed to load scenes: ' + e.message, 'error');
      }
    },

    render() {
      const grid = document.getElementById('scenes-grid');
      if (!state.scenes.length) {
        grid.innerHTML = '<div class="empty-state">No scenes found</div>';
        return;
      }
      grid.innerHTML = state.scenes.map((s) => {
        const name = s.name || 'Unnamed';
        const id = s.id || s.scene_id || '';
        const sType = s.type === 'scene' ? 'Tap-to-Run' : 'Automation';
        const typeClass = s.type === 'scene' ? 'badge-success' : 'badge-category';
        const disabled = s.status === 'disable' ? 'disabled' : '';
        return `
        <div class="card scene-card">
          <div>
            <div class="scene-name">${esc(name)}</div>
            <div class="scene-id">
              <span class="badge ${typeClass}">${esc(sType)}</span>
              ${s.status === 'disable'
                ? '<span class="badge badge-danger">disabled</span>' : ''}
            </div>
          </div>
          <button class="btn btn-primary btn-sm" ${disabled}
            onclick="pages.scenes.trigger('${esc(id)}', this)">Trigger</button>
        </div>`;
      }).join('');
    },

    async trigger(ruleId, btn) {
      if (btn) btn.disabled = true;
      try {
        await api.post(`/api/scenes/${encodeURIComponent(ruleId)}/trigger`);
        toast('Scene triggered', 'success');
      } catch (e) {
        toast('Trigger failed: ' + e.message, 'error');
      } finally {
        if (btn) setTimeout(() => { btn.disabled = false; }, 1000);
      }
    },

    setHomeId() {
      const val = document.getElementById('home-id-input').value.trim();
      if (!val) return;
      // Manual entry: treat as space ID and fetch.
      api.get(`/api/spaces/${encodeURIComponent(val)}/scenes`)
        .then((data) => {
          state.scenes = data.list || (Array.isArray(data) ? data : []);
          this.render();
          document.getElementById('scenes-home-input').style.display = 'none';
        })
        .catch((e) => toast('Failed: ' + e.message, 'error'));
    },
  },

  /* ── Logs ── */
  logs: {
    _loaded: false,

    load() {
      const sel = document.getElementById('log-device');
      const existing = sel.value;
      sel.innerHTML = '<option value="">All Devices</option>' +
        state.devices.map((d) => {
          const label = deviceName(d);
          return `<option value="${esc(d.id)}">${esc(label)}</option>`;
        }).join('');
      sel.value = existing;

      const now = new Date();
      const yesterday = new Date(now.getTime() - 86400000);
      if (!document.getElementById('log-start').value) {
        document.getElementById('log-start').value = formatISOLocal(yesterday);
      }
      if (!document.getElementById('log-end').value) {
        document.getElementById('log-end').value = formatISOLocal(now);
      }

      // Auto-search on first visit to show latest logs immediately.
      if (!this._loaded) {
        this._loaded = true;
        this.search();
      }
    },

    async search() {
      const deviceId = document.getElementById('log-device').value;
      const start = document.getElementById('log-start').value;
      const end = document.getElementById('log-end').value;
      const code = document.getElementById('log-code').value.trim();

      const params = new URLSearchParams();
      if (deviceId) params.set('device_id', deviceId);
      if (start) params.set('start_time', new Date(start).getTime().toString());
      if (end) params.set('end_time', new Date(end).getTime().toString());
      if (code) params.set('code', code);
      params.set('limit', '100');
      params.set('offset', '0');

      try {
        const data = await api.get('/api/logs?' + params.toString());
        const logs = data.logs || [];
        const total = data.total != null ? data.total : logs.length;

        document.getElementById('logs-count').textContent = `${total} log(s) found`;

        if (!logs.length) {
          document.getElementById('logs-table-wrap').innerHTML =
            '<div class="empty-state">No logs match the query</div>';
          return;
        }

        const deviceMap = {};
        state.devices.forEach((d) => { deviceMap[d.id] = deviceName(d); });

        let html = `<div class="table-wrap"><table>
          <thead><tr>
            <th>Time</th><th>Device</th><th>Code</th><th>Value</th><th>Source</th>
          </tr></thead>
          <tbody>`;
        logs.forEach((l) => {
          const ts = formatTime(l.event_time || l.timestamp);
          const devLabel = esc(deviceMap[l.device_id] || l.device_id || '');
          html += `<tr>
            <td>${esc(ts)}</td>
            <td class="mono" title="${esc(l.device_id)}">${devLabel}</td>
            <td class="mono">${esc(l.code)}</td>
            <td class="mono">${esc(
              typeof l.value === 'object' ? JSON.stringify(l.value) : l.value
            )}</td>
            <td>${esc(l.source || '')}</td>
          </tr>`;
        });
        html += '</tbody></table></div>';
        document.getElementById('logs-table-wrap').innerHTML = html;
      } catch (e) {
        toast('Log search failed: ' + e.message, 'error');
      }
    },
  },

  /* ── Events ── */
  events: {
    load() {
      state.unseenEvents = 0;
      this.updateBadge();
      this.renderFeed();
      this.connect();
    },

    connect() {
      if (state.eventSource) return;
      this.setStatus('connecting');
      const es = new EventSource('/api/events/stream');
      state.eventSource = es;

      es.onopen = () => { this.setStatus('connected'); };
      es.onmessage = (e) => {
        try {
          const data = JSON.parse(e.data);
          state.events.unshift(data);
          if (state.events.length > 500) state.events.length = 500;

          if (state.currentPage === 'events') {
            this.prependEvent(data);
          } else {
            state.unseenEvents++;
            this.updateBadge();
          }
        } catch { /* ignore malformed */ }
      };
      es.onerror = () => {
        this.setStatus('disconnected');
        state.eventSource.close();
        state.eventSource = null;
        setTimeout(() => this.connect(), 5000);
      };
    },

    setStatus(s) {
      const dot = document.getElementById('event-status-dot');
      const txt = document.getElementById('event-status-text');
      dot.className = 'event-status-dot ' + s;
      txt.textContent = s.charAt(0).toUpperCase() + s.slice(1);
    },

    updateBadge() {
      const badge = document.getElementById('event-badge');
      if (state.unseenEvents > 0) {
        badge.textContent = state.unseenEvents > 99 ? '99+' : state.unseenEvents;
        badge.classList.add('visible');
      } else {
        badge.classList.remove('visible');
      }
    },

    renderFeed() {
      const feed = document.getElementById('event-feed');
      if (!state.events.length) {
        feed.innerHTML =
          '<div class="empty-state">No events yet. Waiting for data...</div>';
        return;
      }
      feed.innerHTML = state.events.map((ev) => this.eventHTML(ev)).join('');
    },

    prependEvent(ev) {
      const feed = document.getElementById('event-feed');
      if (feed.querySelector('.empty-state')) feed.innerHTML = '';
      feed.insertAdjacentHTML('afterbegin', this.eventHTML(ev));
      while (feed.children.length > 500) feed.lastChild.remove();
    },

    eventHTML(ev) {
      const ts = formatTime(ev.timestamp);
      const color = eventTypeColor(ev.event_type);
      const dataStr = typeof ev.data === 'object'
        ? JSON.stringify(ev.data, null, 2) : esc(ev.data || '');
      return `
        <div class="event-item">
          <div class="event-item-header">
            <span class="event-time">${esc(ts)}</span>
            <span class="event-type" style="background:${color}22;color:${color};">
              ${esc(ev.event_type || 'unknown')}</span>
            <span class="event-device">${esc(ev.device_id || '')}</span>
          </div>
          ${dataStr ? `<div class="event-data">${esc(dataStr)}</div>` : ''}
        </div>`;
    },
  },

  /* ── Status ── */
  status: {
    async load() {
      try {
        const [stats, bookmarks, runs] = await Promise.all([
          api.get('/api/logs/stats'),
          api.get('/api/logs/bookmarks').catch(() => []),
          api.get('/api/logs/runs').catch(() => []),
        ]);

        const runList = Array.isArray(runs) ? runs : (runs.runs || []);
        const bookmarkList = Array.isArray(bookmarks) ? bookmarks : [];

        document.getElementById('status-stats').innerHTML = `
          <div class="stat-card">
            <div class="stat-number">${esc(
              stats.total_logs != null ? stats.total_logs : '---'
            )}</div>
            <div class="stat-label">Total Logs</div>
          </div>
          <div class="stat-card">
            <div class="stat-number">${esc(
              stats.total_devices != null ? stats.total_devices : '---'
            )}</div>
            <div class="stat-label">Devices Tracked</div>
          </div>
          <div class="stat-card">
            <div class="stat-number">${esc(
              stats.total_runs != null ? stats.total_runs : '---'
            )}</div>
            <div class="stat-label">Collection Runs</div>
          </div>`;

        if (bookmarkList.length) {
          let bhtml = '<table><thead><tr>' +
            '<th>Device ID</th><th>Last Event Time</th>' +
            '</tr></thead><tbody>';
          bookmarkList.forEach((b) => {
            bhtml += `<tr>
              <td class="mono">${esc(b.device_id)}</td>
              <td>${esc(formatTime(b.last_event_time))}</td>
            </tr>`;
          });
          bhtml += '</tbody></table>';
          document.getElementById('status-bookmarks').innerHTML = bhtml;
        } else {
          document.getElementById('status-bookmarks').innerHTML =
            '<div class="empty-state">No bookmarks</div>';
        }

        if (runList.length) {
          let rhtml = '<table><thead><tr>' +
            '<th>ID</th><th>Started</th><th>Duration</th>' +
            '<th>Devices</th><th>Logs</th><th>Status</th>' +
            '</tr></thead><tbody>';
          runList.forEach((r) => {
            const started = formatTime(r.started_at);
            let duration = '---';
            if (r.started_at && r.finished_at) {
              const ms = new Date(r.finished_at).getTime() -
                new Date(r.started_at).getTime();
              duration = ms < 1000 ? ms + 'ms' : (ms / 1000).toFixed(1) + 's';
            }
            const statusClass = r.status === 'completed' ? 'badge-success' :
              r.status === 'failed' ? 'badge-danger' : 'badge-warning';
            rhtml += `<tr>
              <td class="mono">${esc(r.id)}</td>
              <td>${esc(started)}</td>
              <td>${esc(duration)}</td>
              <td>${esc(
                r.devices_count != null ? r.devices_count : '---'
              )}</td>
              <td>${esc(
                r.logs_collected != null ? r.logs_collected : '---'
              )}</td>
              <td><span class="badge ${statusClass}">${
                esc(r.status || 'unknown')
              }</span></td>
            </tr>`;
          });
          rhtml += '</tbody></table>';
          document.getElementById('status-runs').innerHTML = rhtml;
        } else {
          document.getElementById('status-runs').innerHTML =
            '<div class="empty-state">No collection runs recorded</div>';
        }
      } catch (e) {
        toast('Failed to load status: ' + e.message, 'error');
      }
    },
  },
};

/* ─────────────────────────── Navigation ─────────────────────────── */
function navigate(page) {
  state.currentPage = page;

  document.querySelectorAll('.page-section').forEach((el) => {
    el.classList.remove('active');
  });
  const target = document.getElementById('page-' + page);
  if (target) target.classList.add('active');

  document.querySelectorAll('.sidebar-nav a').forEach((a) => {
    a.classList.toggle('active', a.getAttribute('data-page') === page);
  });

  if (pages[page] && typeof pages[page].load === 'function') {
    pages[page].load();
  }
}

/* ─────────────────────────── Init ─────────────────────────── */
document.addEventListener('DOMContentLoaded', async () => {
  navigate('devices');
  pages.events.connect();
});
</script>
</body>
</html>
